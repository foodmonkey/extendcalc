Yes, you can read configuration data at runtime and make it globally accessible to all modules in your Rust application
. The idiomatic approach in safe, multi-threaded Rust involves using thread-safe lazy initialization mechanisms.
The modern, standard library solution (since Rust 1.70) is to use std::sync::OnceLock<T> or std::sync::LazyLock<T> (since Rust 1.80) to initialize your configuration struct once and then provide immutable, global access to it.
Recommended Approach: std::sync::LazyLock
The LazyLock type provides the cleanest and safest way to achieve this. It ensures that the initialization code runs only once, the first time the variable is accessed, and is thread-safe.
1. Define your Configuration Struct
First, define a struct to hold your configuration variables. It's best practice to use types like String that can be dynamically populated at runtime



2. Use LazyLock for Global Access
Declare a pub static variable using LazyLock (or OnceLock in older Rust versions) in your configuration module.
Note: LazyLock is stable as of Rust 1.80. If you are using an older version, the lazy_static crate provides similar functionality via a macro.

3. Access the Configuration in Any Module
Now, any module in your application can access the configuration by importing APP_CONFIG and treating it like a normal reference, without needing unsafe blocks or explicit locking mechanism

Alternatives and Best Practices

    Avoid static mut: Directly using static mut is possible but highly discouraged in safe Rust as it can lead to data races and undefined behavior.
    Pass as parameters: The most idiomatic Rust approach is to avoid global state entirely and pass a reference or a smart pointer (like Arc<Config>) to functions or structs that need it. The lazy global method serves as a convenient alternative when passing parameters becomes cumbersome.
    Use the config crate: For complex configuration management (layered files, environment variables, etc.), consider using the popular config crate
